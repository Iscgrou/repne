import TelegramBot from "node-telegram-bot-api";
import { db } from "~/server/db";
import { getAuth, queueTask, getTaskStatus } from "~/server/actions";

// ===== PHASE 4: DATA CONTRACTS & TYPES =====
// ⁄Øÿ≤ÿßÿ±ÿ¥ Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿ®ÿ±ÿß€å ÿßÿ±ÿßÿ¶Ÿá ÿ®ÿßÿ≤ÿÆŸàÿ±ÿØ ÿØŸÇ€åŸÇ ÿ®Ÿá ÿßÿØŸÖ€åŸÜ
export type ProcessingReport = {
  totalRecords: number;
  successCount: number;
  skippedInactive: number;
  newlyOnboarded: string[]; // ŸÑ€åÿ≥ÿ™€å ÿßÿ≤ ⁄©ÿØŸáÿß€å ŸÜŸÖÿß€åŸÜÿØ⁄ØÿßŸÜ ÿ¨ÿØ€åÿØ
  errors: { identifier: string; reason: string }[];
};

// ÿ≥ÿßÿÆÿ™ÿßÿ± €å⁄© ÿ±⁄©Ÿàÿ±ÿØ ÿÆÿßŸÖ ÿßÿ≤ ŸÅÿß€åŸÑ JSON Ÿàÿ±ŸàÿØ€å
export type RawMarzbanRecord = {
  admin_username: string;
  limited_1_month_volume: string;
  limited_2_month_volume: string;
  limited_3_month_volume: string;
  limited_4_month_volume: string;
  limited_5_month_volume: string;
  limited_6_month_volume: string;
  unlimited_1_month: string;
  unlimited_2_month: string;
  unlimited_3_month: string;
  unlimited_4_month: string;
  unlimited_5_month: string;
  unlimited_6_month: string;
  [key: string]: any; // ÿ®ÿ±ÿß€å ÿ≥ÿß€åÿ± ŸÅ€åŸÑÿØŸáÿß€å ÿßÿ≠ÿ™ŸÖÿßŸÑ€å
};

// ÿ≥ÿßÿÆÿ™ÿßÿ± ÿßÿ≥ÿ™ÿßŸÜÿØÿßÿ±ÿØ ÿ¥ÿØŸá ⁄©Ÿá ÿØÿ± ⁄©ŸÑ ÿ≥€åÿ≥ÿ™ŸÖ ŸÖÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿÆŸàÿßŸáÿØ ÿ¥ÿØ
export type StandardizedActivityRecord = {
  representativeIdentifier: string;
  // ÿØÿ± ÿ¢€åŸÜÿØŸá ŸÖ€å‚Äåÿ™ŸàÿßŸÜ ÿ¨ÿ≤ÿ¶€åÿßÿ™ ÿ®€åÿ¥ÿ™ÿ±€å ÿßÿ≤ ŸÅÿß€åŸÑ ÿÆŸàÿßŸÜÿØ
  representativeDetails: {
    persianFullName: string;
    contact: { mobile: string | null; email: string | null };
  };
  usageData: {
    tier1_Volume: number;
    tier2_Volume: number;
    tier3_Volume: number;
    tier4_Volume: number;
    tier5_Volume: number;
    tier6_Volume: number;
    tier7_Volume: number;
    tier8_Volume: number;
    tier9_Volume: number;
    tier10_Volume: number;
    tier11_Volume: number;
    tier12_Volume: number;
    discountAmount: number; // ÿ®ÿ±ÿß€å ÿ¢€åŸÜÿØŸá
    additionalFee: number; // ÿ®ÿ±ÿß€å ÿ¢€åŸÜÿØŸá
  };
  // ⁄©Ÿæ€å ⁄©ÿßŸÖŸÑ ÿ±⁄©Ÿàÿ±ÿØ ÿÆÿßŸÖ ÿ®ÿ±ÿß€å ÿ≠ÿ≥ÿßÿ®ÿ±ÿ≥€å
  rawRecord: RawMarzbanRecord;
};

// ===== PHASE 4: MARZBAN JSON ADAPTER =====
/**
 * ÿ¢ÿØÿßŸæÿ™Ÿàÿ± ÿØÿßÿØŸá ÿ®ÿ±ÿß€å ÿ™ÿ®ÿØ€åŸÑ ŸÅÿß€åŸÑ JSON ÿÆÿßŸÖ ÿ®Ÿá ÿ≥ÿßÿÆÿ™ÿßÿ± ÿßÿ≥ÿ™ÿßŸÜÿØÿßÿ±ÿØ
 * ÿß€åŸÜ ⁄©ŸÑÿßÿ≥ €å⁄© "ŸÖÿ™ÿ±ÿ¨ŸÖ ŸÖÿ™ÿÆÿµÿµ" ÿßÿ≥ÿ™ ⁄©Ÿá ÿ≥ÿßÿÆÿ™ÿßÿ± Ÿæ€å⁄Ü€åÿØŸá ŸÅÿß€åŸÑ admins1.json ÿ±ÿß
 * ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ÿßÿ≥ÿ™ÿßŸÜÿØÿßÿ±ÿØ Ÿà ÿ™ŸÖ€åÿ≤ ÿ™ÿ®ÿØ€åŸÑ ŸÖ€å‚Äå⁄©ŸÜÿØ
 */
export class MarzbanJsonAdapter {
  public static transform(rawJson: any[]): StandardizedActivityRecord[] {
    console.log("üîÑ Starting Marzban JSON transformation...");

    // 1. Ÿæ€åÿØÿß ⁄©ÿ±ÿØŸÜ ÿ¥€åÿ° ÿ¨ÿØŸàŸÑ ÿØÿßÿØŸá‚ÄåŸáÿß
    const tableObject = rawJson.find(
      (item) => item.type === "table" && item.name === "a",
    );
    if (!tableObject || !Array.isArray(tableObject.data)) {
      throw new Error("ÿ≥ÿßÿÆÿ™ÿßÿ± ŸÅÿß€åŸÑ ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™: ÿ¥€åÿ° ÿ¨ÿØŸàŸÑ ÿØÿßÿØŸá 'a' €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.");
    }

    const sourceData: RawMarzbanRecord[] = tableObject.data;
    console.log(`üìä Found ${sourceData.length} raw records to process`);

    const standardizedRecords: StandardizedActivityRecord[] = [];

    // 2. ÿ≠ŸÑŸÇŸá ÿ±Ÿà€å ÿØÿßÿØŸá‚ÄåŸáÿß€å ÿÆÿßŸÖ Ÿà ÿ™ÿ®ÿØ€åŸÑ ÿ¢ŸÜ‚ÄåŸáÿß
    for (const record of sourceData) {
      if (!record || !record.admin_username) {
        console.log("‚ö†Ô∏è Skipping invalid record:", record);
        continue; // ŸÜÿßÿØ€åÿØŸá ⁄Øÿ±ŸÅÿ™ŸÜ ÿ±⁄©Ÿàÿ±ÿØŸáÿß€å ŸÜÿßŸÖÿπÿ™ÿ®ÿ±
      }

      const standardRecord: StandardizedActivityRecord = {
        representativeIdentifier: record.admin_username,
        representativeDetails: {
          persianFullName: record.admin_username, // Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂
          contact: { mobile: null, email: null },
        },
        usageData: {
          // ŸÜ⁄Øÿßÿ¥ÿ™ ÿØŸÇ€åŸÇ €±€≤ ÿ≥ÿ∑ÿ≠ ÿ≥ÿ±Ÿà€åÿ≥ ÿ®ÿß ÿ™ÿ®ÿØ€åŸÑ ÿ±ÿ¥ÿ™Ÿá ÿ®Ÿá ÿπÿØÿØ
          tier1_Volume: parseFloat(record.limited_1_month_volume) || 0,
          tier2_Volume: parseFloat(record.limited_2_month_volume) || 0,
          tier3_Volume: parseFloat(record.limited_3_month_volume) || 0,
          tier4_Volume: parseFloat(record.limited_4_month_volume) || 0,
          tier5_Volume: parseFloat(record.limited_5_month_volume) || 0,
          tier6_Volume: parseFloat(record.limited_6_month_volume) || 0,
          tier7_Volume: parseInt(record.unlimited_1_month, 10) || 0,
          tier8_Volume: parseInt(record.unlimited_2_month, 10) || 0,
          tier9_Volume: parseInt(record.unlimited_3_month, 10) || 0,
          tier10_Volume: parseInt(record.unlimited_4_month, 10) || 0,
          tier11_Volume: parseInt(record.unlimited_5_month, 10) || 0,
          tier12_Volume: parseInt(record.unlimited_6_month, 10) || 0,
          discountAmount: 0,
          additionalFee: 0,
        },
        rawRecord: record, // ÿ∞ÿÆ€åÿ±Ÿá ÿ±⁄©Ÿàÿ±ÿØ ÿÆÿßŸÖ ÿ®ÿ±ÿß€å ÿ≠ÿ≥ÿßÿ®ÿ±ÿ≥€å
      };

      standardizedRecords.push(standardRecord);
    }

    console.log(
      `‚úÖ Successfully transformed ${standardizedRecords.length} records`,
    );
    return standardizedRecords;
  }

  /**
   * ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å ÿ≥ÿßÿÆÿ™ÿßÿ± ŸÅÿß€åŸÑ JSON Ÿàÿ±ŸàÿØ€å
   */
  public static validateJsonStructure(rawJson: any): boolean {
    try {
      if (!Array.isArray(rawJson)) {
        console.error("‚ùå JSON must be an array");
        return false;
      }

      const tableObject = rawJson.find(
        (item) => item.type === "table" && item.name === "a",
      );
      if (!tableObject) {
        console.error('‚ùå Missing table object with name "a"');
        return false;
      }

      if (!Array.isArray(tableObject.data)) {
        console.error("‚ùå Table object data must be an array");
        return false;
      }

      console.log("‚úÖ JSON structure validation passed");
      return true;
    } catch (error) {
      console.error("‚ùå JSON structure validation failed:", error);
      return false;
    }
  }
}

// Authentication & User Management
export async function getCurrentUser() {
  const auth = await getAuth();
  if (auth.status === "unauthenticated") return null;

  return await db.user.findUnique({
    where: { id: auth.userId },
  });
}

export async function setCurrentUserAsAdmin() {
  const { userId } = await getAuth({ required: true });

  return await db.user.upsert({
    where: { id: userId },
    update: { isAdmin: true },
    create: { id: userId, isAdmin: true },
  });
}

// Representative Management
export async function listRepresentatives() {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.representative.findMany({
    orderBy: { createdAt: "desc" },
    include: {
      salesCollaborator: true,
      _count: {
        select: { invoices: true },
      },
    },
  });
}

import { z } from "zod";

const createRepresentativeSchema = z.object({
  representativeCode: z.string().min(1),
  persianFullName: z.string().min(1),
  contactInfo: z.string().optional(),
  salesCollaboratorId: z.string().optional(),
});

export async function createRepresentative(input: {
  representativeCode: string;
  persianFullName: string;
  contactInfo?: string;
  salesCollaboratorId?: string;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  // Input validation
  const safeInput = createRepresentativeSchema.parse(input);

  return await db.representative.create({
    data: safeInput,
  });
}

export async function getRepresentative({ id }: { id: string }) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.representative.findUnique({
    where: { id },
    include: {
      salesCollaborator: true,
      invoices: {
        orderBy: { createdAt: "desc" },
        take: 10,
      },
    },
  });
}

// Invoice Management
export async function listInvoices() {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.invoice.findMany({
    orderBy: { createdAt: "desc" },
    include: {
      representative: true,
      items: true,
    },
  });
}

export async function createInvoice(input: {
  representativeId: string;
  dueDate: string;
  notes?: string;
  items: Array<{
    description: string;
    quantity: number;
    unitPrice: number;
  }>;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  // Generate invoice number
  const invoiceCount = await db.invoice.count();
  const invoiceNumber = `INV-${String(invoiceCount + 1).padStart(6, "0")}`;

  // Calculate totals
  let totalAmount = 0;
  const processedItems = input.items.map((item) => {
    const total = item.quantity * item.unitPrice;
    totalAmount += total;
    return {
      description: item.description,
      quantity: item.quantity,
      unitPrice: item.unitPrice,
      total,
    };
  });

  return await db.invoice.create({
    data: {
      invoiceNumber,
      representativeId: input.representativeId,
      dueDate: new Date(input.dueDate),
      notes: input.notes,
      totalAmount,
      items: {
        create: processedItems,
      },
    },
    include: {
      representative: true,
      items: true,
    },
  });
}

export async function getInvoice({ id }: { id: string }) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.invoice.findUnique({
    where: { id },
    include: {
      representative: true,
      items: true,
    },
  });
}

export async function updateInvoiceStatus(input: {
  id: string;
  status: string;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.invoice.update({
    where: { id: input.id },
    data: { status: input.status },
  });
}

// Dashboard Analytics
export async function getDashboardStats() {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const [
    totalInvoices,
    totalRepresentatives,
    paidInvoices,
    overdueInvoices,
    totalRevenue,
  ] = await Promise.all([
    db.invoice.count(),
    db.representative.count(),
    db.invoice.count({ where: { status: "PAID" } }),
    db.invoice.count({ where: { status: "OVERDUE" } }),
    db.invoice.aggregate({
      where: { status: "PAID" },
      _sum: { totalAmount: true },
    }),
  ]);

  return {
    totalInvoices,
    totalRepresentatives,
    paidInvoices,
    overdueInvoices,
    totalRevenue: totalRevenue._sum.totalAmount || 0,
    pendingInvoices: totalInvoices - paidInvoices - overdueInvoices,
  };
}

// System Configuration
export async function getSystemConfig() {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const configs = await db.systemConfig.findMany();
  return configs.reduce(
    (acc, config) => {
      acc[config.key] = config.value;
      return acc;
    },
    {} as Record<string, string>,
  );
}

export async function updateSystemConfig(input: {
  key: string;
  value: string;
  description?: string;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.systemConfig.upsert({
    where: { key: input.key },
    update: { value: input.value, description: input.description },
    create: input,
  });
}

// ===== PHASE 4: INVOICE GENERATION SERVICE =====
/**
 * ÿ≥ÿ±Ÿà€åÿ≥ ÿµÿØŸàÿ± ŸÅÿß⁄©ÿ™Ÿàÿ± - ŸÖÿ∫ÿ≤ ÿπŸÖŸÑ€åÿßÿ™ ŸÖÿßŸÑ€å
 * ÿß€åŸÜ ÿ≥ÿ±Ÿà€åÿ≥ Ÿá€å⁄Ü‚Äå⁄Ü€åÿ≤ ÿØÿ± ŸÖŸàÿ±ÿØ ŸÅÿß€åŸÑ JSON ŸÜŸÖ€å‚ÄåÿØÿßŸÜÿØ
 * Ÿàÿ±ŸàÿØ€å: ÿØÿßÿØŸá‚ÄåŸáÿß€å ÿ™ŸÖ€åÿ≤ Ÿà ÿßÿ≥ÿ™ÿßŸÜÿØÿßÿ±ÿØ ÿßÿ≤ ÿ¢ÿØÿßŸæÿ™Ÿàÿ±
 * ÿÆÿ±Ÿàÿ¨€å: ÿ±⁄©Ÿàÿ±ÿØŸáÿß€å ÿØŸÇ€åŸÇ ÿØÿ± ÿØ€åÿ™ÿßÿ®€åÿ≥
 * ÿ™ŸÖÿßŸÖ ÿπŸÖŸÑ€åÿßÿ™ ÿØÿ± €å⁄© ÿ™ÿ±ÿß⁄©ŸÜÿ¥ Ÿàÿßÿ≠ÿØ (Atomic Transaction) ÿßŸÜÿ¨ÿßŸÖ ŸÖ€å‚Äåÿ¥ŸàÿØ
 */
export class InvoiceGenerationService {
  public static async generateInvoicesFromActivityData(
    activityRecords: StandardizedActivityRecord[],
  ): Promise<ProcessingReport> {
    console.log("üß† Starting Invoice Generation Service...");

    const report: ProcessingReport = {
      totalRecords: activityRecords.length,
      successCount: 0,
      skippedInactive: 0,
      newlyOnboarded: [],
      errors: [],
    };

    // ÿßÿ¨ÿ±ÿß€å ÿ™ŸÖÿßŸÖ ÿπŸÖŸÑ€åÿßÿ™ ÿØÿ± €å⁄© ÿ™ÿ±ÿß⁄©ŸÜÿ¥ Ÿàÿßÿ≠ÿØ ÿ®ÿ±ÿß€å ÿ™ÿ∂ŸÖ€åŸÜ €å⁄©Ÿæÿßÿ±⁄Ü⁄Ø€å ÿØÿßÿØŸá
    await db.$transaction(async (tx) => {
      console.log(
        `üîÑ Processing ${activityRecords.length} activity records in transaction...`,
      );

      for (const record of activityRecords) {
        try {
          // --- ⁄ØÿßŸÖ €±: ÿ¥ŸÜÿßÿ≥ÿß€å€å €åÿß ÿ¢ŸÜÿ®Ÿàÿ±ÿØ€åŸÜ⁄Ø ŸáŸàÿ¥ŸÖŸÜÿØ ŸÜŸÖÿß€åŸÜÿØŸá ---
          let representative = await tx.representative.findUnique({
            where: { representativeCode: record.representativeIdentifier },
            include: { salesCollaborator: true },
          });

          if (!representative) {
            console.log(
              `üÜï Smart onboarding for representative: ${record.representativeIdentifier}`,
            );

            // ÿ¢ŸÜÿ®Ÿàÿ±ÿØ€åŸÜ⁄Ø ŸáŸàÿ¥ŸÖŸÜÿØ: ÿß€åÿ¨ÿßÿØ ŸÜŸÖÿß€åŸÜÿØŸá ÿ®ÿß ÿ™ÿπÿ±ŸÅŸá‚ÄåŸáÿß€å Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂
            // ÿØÿ±€åÿßŸÅÿ™ ÿ™ÿπÿ±ŸÅŸá‚ÄåŸáÿß€å Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ ÿßÿ≤ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ≥€åÿ≥ÿ™ŸÖ
            const defaultPricing = await this.getDefaultPricingTiers();

            // ÿßŸÜÿ™ÿÆÿßÿ® ŸáŸÖ⁄©ÿßÿ± ŸÅÿ±Ÿàÿ¥ Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ (ÿßŸàŸÑ€åŸÜ ŸáŸÖ⁄©ÿßÿ± ŸÅÿπÿßŸÑ)
            const defaultCollaborator = await tx.salesCollaborator.findFirst({
              where: { isActive: true },
              orderBy: { createdAt: "asc" },
            });

            representative = await tx.representative.create({
              data: {
                representativeCode: record.representativeIdentifier,
                persianFullName: record.representativeDetails.persianFullName,
                contactInfo: JSON.stringify(
                  record.representativeDetails.contact,
                ),
                salesCollaboratorId: defaultCollaborator?.id || null,
                isActive: true,
                balance: 0,
                // ÿ™ÿπÿ±ŸÅŸá‚ÄåŸáÿß€å Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂
                price_tier1: defaultPricing.tier1,
                price_tier2: defaultPricing.tier2,
                price_tier3: defaultPricing.tier3,
                price_tier4: defaultPricing.tier4,
                price_tier5: defaultPricing.tier5,
                price_tier6: defaultPricing.tier6,
                price_tier7: defaultPricing.tier7,
                price_tier8: defaultPricing.tier8,
                price_tier9: defaultPricing.tier9,
                price_tier10: defaultPricing.tier10,
                price_tier11: defaultPricing.tier11,
                price_tier12: defaultPricing.tier12,
              },
              include: { salesCollaborator: true },
            });

            report.newlyOnboarded.push(representative.representativeCode);
            console.log(
              `‚úÖ Representative created: ${representative.representativeCode}`,
            );
          }

          // --- ⁄ØÿßŸÖ €≤: ÿ®ÿ±ÿ±ÿ≥€å Ÿàÿ∂ÿπ€åÿ™ ŸÅÿπÿßŸÑ€åÿ™ ---
          if (!representative.isActive) {
            console.log(
              `‚è≠Ô∏è Skipping inactive representative: ${representative.representativeCode}`,
            );
            report.skippedInactive++;
            continue; // ÿ®ÿ±Ÿà ÿ®Ÿá ÿ±⁄©Ÿàÿ±ÿØ ÿ®ÿπÿØ€å
          }

          // --- ⁄ØÿßŸÖ €≥: ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ŸÖÿ®ŸÑÿ∫ ŸÅÿß⁄©ÿ™Ÿàÿ± ÿ®ÿ± ÿßÿ≥ÿßÿ≥ €±€≤ ÿ≥ÿ∑ÿ≠ ÿ™ÿπÿ±ŸÅŸá ---
          let totalAmount = 0;
          const invoiceItemsData: any[] = [];

          for (let i = 1; i <= 12; i++) {
            const usageKey = `tier${i}_Volume` as keyof typeof record.usageData;
            const priceKey = `price_tier${i}` as keyof typeof representative;

            const quantity = record.usageData[usageKey];
            const unitPrice = representative[priceKey] as number;

            if (quantity > 0 && unitPrice > 0) {
              const lineTotal = quantity * unitPrice;
              totalAmount += lineTotal;

              const serviceType = i <= 6 ? "ŸÖÿ≠ÿØŸàÿØ" : "ŸÜÿßŸÖÿ≠ÿØŸàÿØ";
              const unit = i <= 6 ? "⁄Ø€å⁄Øÿßÿ®ÿß€åÿ™" : "ŸÖÿßŸá";

              invoiceItemsData.push({
                description: `ÿ≥ÿ±Ÿà€åÿ≥ ${serviceType} - ÿ≥ÿ∑ÿ≠ ${i} (${quantity} ${unit})`,
                quantity,
                unitPrice: Math.round(unitPrice),
                total: Math.round(lineTotal),
              });
            }
          }

          // ÿßÿπŸÖÿßŸÑ Ÿáÿ≤€åŸÜŸá‚ÄåŸáÿß€å ÿßÿ∂ÿßŸÅ€å Ÿà ÿ™ÿÆŸÅ€åŸÅÿßÿ™
          if (record.usageData.additionalFee > 0) {
            invoiceItemsData.push({
              description: "Ÿáÿ≤€åŸÜŸá ÿßÿ∂ÿßŸÅ€å",
              quantity: 1,
              unitPrice: record.usageData.additionalFee,
              total: record.usageData.additionalFee,
            });
            totalAmount += record.usageData.additionalFee;
          }

          if (record.usageData.discountAmount > 0) {
            invoiceItemsData.push({
              description: "ÿ™ÿÆŸÅ€åŸÅ",
              quantity: 1,
              unitPrice: -record.usageData.discountAmount,
              total: -record.usageData.discountAmount,
            });
            totalAmount -= record.usageData.discountAmount;
          }

          // ÿßÿπŸÖÿßŸÑ ŸÖÿßŸÑ€åÿßÿ™ (9% VAT)
          const taxRate = 0.09;
          const taxAmount = totalAmount * taxRate;
          if (taxAmount > 0) {
            invoiceItemsData.push({
              description: `ŸÖÿßŸÑ€åÿßÿ™ ÿ®ÿ± ÿßÿ±ÿ≤ÿ¥ ÿßŸÅÿ≤ŸàÿØŸá (${(taxRate * 100).toFixed(1)}%)`,
              quantity: 1,
              unitPrice: Math.round(taxAmount),
              total: Math.round(taxAmount),
            });
            totalAmount += taxAmount;
          }

          // --- ⁄ØÿßŸÖ €¥: ÿß€åÿ¨ÿßÿØ ŸÅÿß⁄©ÿ™Ÿàÿ± (ŸÅŸÇÿ∑ ÿß⁄Øÿ± ŸÖÿ®ŸÑÿ∫€å Ÿàÿ¨ŸàÿØ ÿØÿßÿ¥ÿ™Ÿá ÿ®ÿßÿ¥ÿØ) ---
          if (totalAmount > 0) {
            const invoiceNumber = await this.generateUniqueInvoiceNumber(tx);

            const newInvoice = await tx.invoice.create({
              data: {
                invoiceNumber,
                representativeId: representative.id,
                issueDate: new Date(),
                dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 ÿ±Ÿàÿ≤
                totalAmount: Math.round(totalAmount),
                status: "PENDING_PAYMENT",
                notes: `ÿ™ŸàŸÑ€åÿØ ÿ¥ÿØŸá ÿßÿ≤ ÿ≥ÿ±Ÿà€åÿ≥ ÿµÿØŸàÿ± ŸÅÿß⁄©ÿ™Ÿàÿ± - ${new Date().toISOString()}`,
                source_data_snapshot: JSON.stringify(record.rawRecord),
                items: {
                  create: invoiceItemsData,
                },
              },
            });

            console.log(
              `üìÑ Invoice created: ${invoiceNumber} for ${Math.round(totalAmount)} Toman`,
            );

            // --- ⁄ØÿßŸÖ €µ: ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ŸÖŸàÿ¨ŸàÿØ€å ŸÜŸÖÿß€åŸÜÿØŸá ---
            await tx.representative.update({
              where: { id: representative.id },
              data: { balance: { decrement: totalAmount } },
            });

            // --- ⁄ØÿßŸÖ €∂: ŸÖÿ≠ÿßÿ≥ÿ®Ÿá Ÿà ÿ´ÿ®ÿ™ ŸæŸàÿ±ÿ≥ÿßŸÜÿ™ (ÿß⁄Øÿ± ŸáŸÖ⁄©ÿßÿ± ŸÅÿ±Ÿàÿ¥ Ÿàÿ¨ŸàÿØ ÿØÿßÿ¥ÿ™) ---
            if (
              representative.salesCollaborator &&
              representative.salesCollaborator.commissionRate > 0
            ) {
              const commissionAmount =
                (totalAmount *
                  representative.salesCollaborator.commissionRate) /
                100;

              await tx.commissionRecord.create({
                data: {
                  invoiceId: newInvoice.id,
                  salesCollaboratorId: representative.salesCollaborator.id,
                  commissionAmount: Math.round(commissionAmount),
                  commissionRate:
                    representative.salesCollaborator.commissionRate,
                  status: "PENDING",
                  notes: `ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿ¥ÿØŸá ÿ™Ÿàÿ≥ÿ∑ ÿ≥ÿ±Ÿà€åÿ≥ ÿµÿØŸàÿ± ŸÅÿß⁄©ÿ™Ÿàÿ± - ŸÜÿ±ÿÆ ${representative.salesCollaborator.commissionRate}%`,
                },
              });

              await tx.salesCollaborator.update({
                where: { id: representative.salesCollaborator.id },
                data: { balance: { increment: commissionAmount } },
              });

              console.log(
                `üí∞ Commission calculated: ${Math.round(commissionAmount)} Toman for ${representative.salesCollaborator.name}`,
              );
            }

            report.successCount++;
          } else {
            console.log(
              `‚ö†Ô∏è No billable amount for ${record.representativeIdentifier}`,
            );
          }
        } catch (error: any) {
          console.error(
            `‚ùå Error processing record ${record.representativeIdentifier}:`,
            error,
          );
          report.errors.push({
            identifier: record.representativeIdentifier,
            reason: error.message || "ÿÆÿ∑ÿß€å ŸÜÿßÿ¥ŸÜÿßÿÆÿ™Ÿá ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ ÿ±⁄©Ÿàÿ±ÿØ",
          });
        }
      }
    });

    console.log(`üéâ Invoice Generation Service completed:`);
    console.log(`  - Total: ${report.totalRecords}`);
    console.log(`  - Success: ${report.successCount}`);
    console.log(`  - Skipped: ${report.skippedInactive}`);
    console.log(`  - New: ${report.newlyOnboarded.length}`);
    console.log(`  - Errors: ${report.errors.length}`);

    return report;
  }

  /**
   * ÿØÿ±€åÿßŸÅÿ™ ÿ™ÿπÿ±ŸÅŸá‚ÄåŸáÿß€å Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ ÿßÿ≤ ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ≥€åÿ≥ÿ™ŸÖ
   */
  private static async getDefaultPricingTiers() {
    // ÿØÿ± ÿ¢€åŸÜÿØŸá ŸÖ€å‚Äåÿ™ŸàÿßŸÜ ÿß€åŸÜ ŸÖŸÇÿßÿØ€åÿ± ÿ±ÿß ÿßÿ≤ ÿ¨ÿØŸàŸÑ SystemConfig ÿÆŸàÿßŸÜÿØ
    // ŸÅÿπŸÑÿßŸã ÿßÿ≤ ŸÖŸÇÿßÿØ€åÿ± Ÿæ€åÿ¥‚ÄåŸÅÿ±ÿ∂ ÿßÿ≥ÿ™ŸÅÿßÿØŸá ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ
    return {
      tier1: 1500, // ÿ™ÿπÿ±ŸÅŸá Ÿæÿß€åŸá ÿ®ÿ±ÿß€å ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß€å ŸÖÿ≠ÿØŸàÿØ
      tier2: 1500,
      tier3: 1500,
      tier4: 1800, // 20% ÿßŸÅÿ≤ÿß€åÿ¥
      tier5: 2100, // 40% ÿßŸÅÿ≤ÿß€åÿ¥
      tier6: 2400, // 60% ÿßŸÅÿ≤ÿß€åÿ¥
      tier7: 50000, // ÿ™ÿπÿ±ŸÅŸá Ÿæÿß€åŸá ÿ®ÿ±ÿß€å ÿ≥ÿ±Ÿà€åÿ≥‚ÄåŸáÿß€å ŸÜÿßŸÖÿ≠ÿØŸàÿØ
      tier8: 100000, // 2x
      tier9: 150000, // 3x
      tier10: 200000, // 4x
      tier11: 250000, // 5x
      tier12: 300000, // 6x
    };
  }

  /**
   * ÿ™ŸàŸÑ€åÿØ ÿ¥ŸÖÿßÿ±Ÿá ŸÅÿß⁄©ÿ™Ÿàÿ± ŸÖŸÜÿ≠ÿµÿ± ÿ®Ÿá ŸÅÿ±ÿØ
   */
  private static async generateUniqueInvoiceNumber(tx: any): Promise<string> {
    const invoiceCount = await tx.invoice.count();
    const timestamp = Date.now().toString().slice(-6); // ÿ¢ÿÆÿ±€åŸÜ 6 ÿ±ŸÇŸÖ timestamp
    return `INV-${String(invoiceCount + 1).padStart(6, "0")}-${timestamp}`;
  }
}

// ===== PHASE 4: ENHANCED MARZBAN JSON PROCESSING SERVICE =====
/**
 * ÿ≥ÿ±Ÿà€åÿ≥ ÿßÿµŸÑ€å ÿ®ÿ±ÿß€å Ÿæÿ±ÿØÿßÿ≤ÿ¥ ŸÅÿß€åŸÑ JSON Ÿà ÿµÿØŸàÿ± ŸÅÿß⁄©ÿ™Ÿàÿ±
 * ÿß€åŸÜ ÿ≥ÿ±Ÿà€åÿ≥ ÿ¥ÿßŸÖŸÑ ÿ™ŸÖÿßŸÖ ŸÖŸÜÿ∑ŸÇ ŸÖÿßŸÑ€åÿå ÿ¢ŸÜÿ®Ÿàÿ±ÿØ€åŸÜ⁄Ø ŸáŸàÿ¥ŸÖŸÜÿØ Ÿà ŸÖÿ≠ÿßÿ≥ÿ®ÿßÿ™ ŸæŸàÿ±ÿ≥ÿßŸÜÿ™ ÿßÿ≥ÿ™
 */
export async function processMarzbanJsonFile(input: {
  fileContent: string;
  fileName: string;
  autoCreateRepresentatives?: boolean;
  applySmartPricing?: boolean;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  console.log("üöÄ Starting enhanced Marzban JSON processing...");

  try {
    // Parse and validate JSON structure
    const rawJsonData = JSON.parse(input.fileContent);

    // Validate using the adapter
    if (!MarzbanJsonAdapter.validateJsonStructure(rawJsonData)) {
      throw new Error("ŸÅÿß€åŸÑ JSON ÿ≥ÿßÿÆÿ™ÿßÿ± ÿµÿ≠€åÿ≠ Marzban ÿ±ÿß ŸÜÿØÿßÿ±ÿØ");
    }

    // Transform raw data using the adapter
    const standardizedRecords = MarzbanJsonAdapter.transform(
      Array.isArray(rawJsonData) ? rawJsonData : [],
    );
    console.log(
      `üìä Processing ${standardizedRecords.length} standardized records`,
    );

    // Use the dedicated Invoice Generation Service for processing
    const processingReport =
      await InvoiceGenerationService.generateInvoicesFromActivityData(
        standardizedRecords,
      );

    // Get the created invoices for response
    const processedInvoices = await db.invoice.findMany({
      where: {
        createdAt: {
          gte: new Date(Date.now() - 60000), // Last minute
        },
      },
      include: {
        representative: true,
        items: true,
      },
      orderBy: { createdAt: "desc" },
    });

    const newRepresentatives =
      processingReport.newlyOnboarded.length > 0
        ? await db.representative.findMany({
            where: {
              representativeCode: {
                in: processingReport.newlyOnboarded,
              },
            },
          })
        : [];

    // Note: Processing is now handled by InvoiceGenerationService above

    console.log("üéâ Marzban JSON processing completed successfully");

    return {
      success: true,
      processedCount: processingReport.successCount,
      errorCount: processingReport.errors.length,
      newRepresentativesCount: processingReport.newlyOnboarded.length,
      skippedInactive: processingReport.skippedInactive,
      invoices: processedInvoices,
      newRepresentatives,
      errors: processingReport.errors,
      summary: {
        totalRecords: processingReport.totalRecords,
        successfulInvoices: processingReport.successCount,
        autoCreatedRepresentatives: processingReport.newlyOnboarded.length,
        skippedInactiveRepresentatives: processingReport.skippedInactive,
        totalRevenue: processedInvoices.reduce(
          (sum, inv) => sum + inv.totalAmount,
          0,
        ),
        smartPricingApplied: input.applySmartPricing || false,
        atomicTransactionUsed: true,
      },
      processingReport,
    };
  } catch (error) {
    console.error("‚ùå Marzban JSON processing failed:", error);
    throw new Error(
      `Ÿæÿ±ÿØÿßÿ≤ÿ¥ ŸÅÿß€åŸÑ Marzban ÿ®ÿß ÿÆÿ∑ÿß ŸÖŸàÿßÿ¨Ÿá ÿ¥ÿØ: ${error instanceof Error ? error.message : "ÿÆÿ∑ÿß€å ŸÜÿßŸÖÿ¥ÿÆÿµ"}`,
    );
  }
}

// Legacy JSON File Processing (kept for backward compatibility)
export async function processInvoiceJsonFile(input: {
  fileContent: string;
  fileName: string;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  try {
    // Parse the JSON file content
    const jsonData = JSON.parse(input.fileContent);

    // Validate that it's an array of invoice records
    if (!Array.isArray(jsonData)) {
      throw new Error("JSON file must contain an array of invoice records");
    }

    const processedInvoices: any[] = [];
    const errors: any[] = [];

    for (let i = 0; i < jsonData.length; i++) {
      const record = jsonData[i];

      try {
        // Validate required fields
        if (
          !record.representativeCode ||
          !record.items ||
          !Array.isArray(record.items)
        ) {
          throw new Error(
            `Missing required fields: representativeCode or items`,
          );
        }

        // Find representative by code
        const representative = await db.representative.findUnique({
          where: { representativeCode: record.representativeCode },
          include: { salesCollaborator: true },
        });

        if (!representative) {
          throw new Error(
            `Representative with code ${record.representativeCode} not found`,
          );
        }

        // Calculate pricing based on representative's tier pricing
        let totalAmount = 0;
        const processedItems: any[] = [];

        for (const item of record.items) {
          let unitPrice = item.unitPrice;

          // If tier is specified, use representative's tier pricing
          if (item.tier && item.tier >= 1 && item.tier <= 12) {
            const tierField =
              `price_tier${item.tier}` as keyof typeof representative;
            unitPrice = representative[tierField] as number;
          }

          const itemTotal = (item.quantity || 1) * unitPrice;
          totalAmount += itemTotal;

          processedItems.push({
            description:
              item.description || `Service Tier ${item.tier || "N/A"}`,
            quantity: item.quantity || 1,
            unitPrice,
            total: itemTotal,
          });
        }

        // Apply tax if specified
        const taxRate = record.taxRate || 0.1; // Default 10% tax
        const taxAmount = totalAmount * taxRate;
        if (taxAmount > 0) {
          processedItems.push({
            description: `Tax (${(taxRate * 100).toFixed(1)}%)`,
            quantity: 1,
            unitPrice: Math.round(taxAmount),
            total: Math.round(taxAmount),
          });
          totalAmount += taxAmount;
        }

        // Generate invoice number
        const invoiceCount = await db.invoice.count();
        const invoiceNumber =
          record.invoiceNumber ||
          `INV-${String(invoiceCount + i + 1).padStart(6, "0")}`;

        // Create invoice
        const invoice = await db.invoice.create({
          data: {
            invoiceNumber,
            representativeId: representative.id,
            issueDate: record.issueDate
              ? new Date(record.issueDate)
              : new Date(),
            dueDate: record.dueDate
              ? new Date(record.dueDate)
              : new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
            totalAmount: Math.round(totalAmount),
            status: record.status || "PENDING_PAYMENT",
            notes:
              record.notes || `Generated from JSON file: ${input.fileName}`,
            source_data_snapshot: JSON.stringify(record),
            items: {
              create: processedItems,
            },
          },
          include: {
            representative: true,
            items: true,
          },
        });

        // Create commission record if representative has sales collaborator
        if (representative.salesCollaborator) {
          const commissionAmount =
            totalAmount *
            (representative.salesCollaborator.commissionRate / 100);
          await db.commissionRecord.create({
            data: {
              invoiceId: invoice.id,
              salesCollaboratorId: representative.salesCollaborator.id,
              commissionAmount: Math.round(commissionAmount),
              commissionRate: representative.salesCollaborator.commissionRate,
              status: "PENDING",
              notes: `Auto-generated from JSON processing`,
            },
          });
        }

        processedInvoices.push(invoice);
      } catch (error) {
        errors.push({
          recordIndex: i,
          error: error instanceof Error ? error.message : "Unknown error",
          record,
        });
      }
    }

    return {
      success: true,
      processedCount: processedInvoices.length,
      errorCount: errors.length,
      invoices: processedInvoices,
      errors,
    };
  } catch (error) {
    throw new Error(
      `Failed to process JSON file: ${error instanceof Error ? error.message : "Unknown error"}`,
    );
  }
}

// Advanced Financial Calculations
export async function calculateAdvancedFinancials(input: {
  invoiceId: string;
  applyDiscounts?: boolean;
  customTaxRate?: number;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const invoice = await db.invoice.findUnique({
    where: { id: input.invoiceId },
    include: {
      representative: { include: { salesCollaborator: true } },
      items: true,
    },
  });

  if (!invoice) throw new Error("Invoice not found");

  let subtotal = 0;
  const itemCalculations: any[] = [];

  // Calculate base amounts
  for (const item of invoice.items) {
    const itemSubtotal = item.quantity * item.unitPrice;
    subtotal += itemSubtotal;

    itemCalculations.push({
      ...item,
      subtotal: itemSubtotal,
      discountApplied: 0,
      finalAmount: itemSubtotal,
    });
  }

  // Apply volume discounts if enabled
  let discountAmount = 0;
  if (input.applyDiscounts && subtotal > 1000000) {
    // Discount for orders over 1M Toman
    discountAmount = subtotal * 0.05; // 5% discount
  }

  // Calculate tax
  const taxRate = input.customTaxRate || 0.1;
  const taxableAmount = subtotal - discountAmount;
  const taxAmount = taxableAmount * taxRate;

  const finalTotal = taxableAmount + taxAmount;

  // Calculate commission if applicable
  let commissionAmount = 0;
  if (invoice.representative.salesCollaborator) {
    commissionAmount =
      finalTotal *
      (invoice.representative.salesCollaborator.commissionRate / 100);
  }

  return {
    subtotal: Math.round(subtotal),
    discountAmount: Math.round(discountAmount),
    taxableAmount: Math.round(taxableAmount),
    taxAmount: Math.round(taxAmount),
    taxRate,
    finalTotal: Math.round(finalTotal),
    commissionAmount: Math.round(commissionAmount),
    itemCalculations,
    recommendedPaymentTerms: finalTotal > 5000000 ? "NET_45" : "NET_30",
  };
}

// Smart Business Logic for Invoice Processing
export async function processSmartInvoiceWorkflow(input: {
  representativeId: string;
  serviceType: string;
  volume?: number;
  priority?: "LOW" | "NORMAL" | "HIGH" | "URGENT";
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const representative = await db.representative.findUnique({
    where: { id: input.representativeId },
    include: {
      salesCollaborator: true,
      invoices: {
        orderBy: { createdAt: "desc" },
        take: 5,
      },
    },
  });

  if (!representative) throw new Error("Representative not found");

  // Smart tier selection based on volume and history
  let recommendedTier = 6; // Default middle tier

  if (input.volume) {
    if (input.volume > 1000)
      recommendedTier = 1; // Highest volume, best price
    else if (input.volume > 500) recommendedTier = 3;
    else if (input.volume > 100) recommendedTier = 6;
    else if (input.volume > 50) recommendedTier = 9;
    else recommendedTier = 12; // Lowest volume, highest price
  }

  // Adjust based on payment history
  const paidInvoices = representative.invoices.filter(
    (inv) => inv.status === "PAID",
  );
  const paymentReliability =
    paidInvoices.length / Math.max(representative.invoices.length, 1);

  if (paymentReliability > 0.9 && recommendedTier > 1) {
    recommendedTier = Math.max(1, recommendedTier - 2); // Better pricing for reliable customers
  } else if (paymentReliability < 0.5) {
    recommendedTier = Math.min(12, recommendedTier + 2); // Higher pricing for unreliable customers
  }

  // Priority adjustments
  const priorityMultipliers = {
    LOW: 0.95,
    NORMAL: 1.0,
    HIGH: 1.1,
    URGENT: 1.25,
  };

  const tierField =
    `price_tier${recommendedTier}` as keyof typeof representative;
  const basePrice = representative[tierField] as number;
  const adjustedPrice = Math.round(
    basePrice * priorityMultipliers[input.priority || "NORMAL"],
  );

  // Smart payment terms
  let paymentTerms = "NET_30";
  if (paymentReliability > 0.95) paymentTerms = "NET_45";
  else if (paymentReliability < 0.7) paymentTerms = "NET_15";
  if (input.priority === "URGENT") paymentTerms = "NET_15";

  // Auto-generate recommended invoice items
  const recommendedItems = [
    {
      description: `${input.serviceType} - Tier ${recommendedTier} Service`,
      quantity: input.volume || 1,
      unitPrice: adjustedPrice,
      tier: recommendedTier,
    },
  ];

  return {
    representativeInfo: {
      name: representative.persianFullName,
      code: representative.representativeCode,
      paymentReliability: Math.round(paymentReliability * 100),
      totalInvoices: representative.invoices.length,
    },
    recommendations: {
      tier: recommendedTier,
      unitPrice: adjustedPrice,
      paymentTerms,
      priority: input.priority || "NORMAL",
      estimatedDelivery: input.priority === "URGENT" ? "1-2 days" : "5-7 days",
    },
    recommendedItems,
    smartInsights: {
      volumeDiscount:
        input.volume && input.volume > 500
          ? "Eligible for volume pricing"
          : null,
      loyaltyBonus:
        paymentReliability > 0.9
          ? "Loyal customer - preferential pricing applied"
          : null,
      riskAlert:
        paymentReliability < 0.5 ? "Payment history requires attention" : null,
    },
  };
}

// Phase 3: Comprehensive Seeding with Exact Pricing Algorithm
export async function _seedAdvancedBusinessLogic() {
  console.log("üöÄ Advanced seeding process started...");

  // 1. Purge old data to ensure idempotency (order matters due to foreign key constraints)
  console.log("üßπ Purging existing data...");
  try {
    await db.commissionRecord.deleteMany();
    await db.commissionPayout.deleteMany();
    await db.paymentAllocation.deleteMany();
    await db.payment.deleteMany();
    await db.invoiceItem.deleteMany();
    await db.invoice.deleteMany();
    await db.crmInteraction.deleteMany();
    await db.representative.deleteMany();
    await db.salesCollaborator.deleteMany();
    await db.systemConfig.deleteMany();
    console.log("‚úÖ Data purged successfully.");
  } catch {
    console.log("Note: Some tables may not exist yet, continuing...");
  }

  // 2. Create system configurations
  console.log("‚öôÔ∏è Creating system configurations...");
  const systemConfigs = [
    {
      key: "company_name",
      value: "Phoenix Invoice System",
      description: "Company name for invoices",
    },
    {
      key: "company_address",
      value: "ÿ™Ÿáÿ±ÿßŸÜÿå ÿß€åÿ±ÿßŸÜ",
      description: "Company address for invoices",
    },
    {
      key: "company_email",
      value: "info@phoenix-invoice.com",
      description: "Company email for invoices",
    },
    {
      key: "tax_rate",
      value: "0.09",
      description: "Default tax rate (9% VAT)",
    },
    {
      key: "default_currency",
      value: "IRR",
      description: "Default currency for invoices (Iranian Rial/Toman)",
    },
    {
      key: "admin_username",
      value: "mgr",
      description: "Default admin username",
    },
  ];

  await Promise.all(
    systemConfigs.map((config) =>
      db.systemConfig.upsert({
        where: { key: config.key },
        update: config,
        create: config,
      }),
    ),
  );
  console.log(`‚úÖ ${systemConfigs.length} system configurations created.`);

  // 3. Create sales collaborators with exact specifications
  console.log("ü§ù Creating sales collaborators...");
  const salesCollaborators = [
    {
      name: "ÿ≥ÿπ€åÿØ ŸÇÿ±ÿßÿ±€å",
      commissionRate: 5.0, // 5% commission
      balance: 0.0,
      isActive: true,
    },
    {
      name: "ÿ®ŸáŸÜÿßŸÖ",
      commissionRate: 7.5, // 7.5% commission
      balance: 0.0,
      isActive: true,
    },
    {
      name: "ÿßŸàŸÜÿ±",
      commissionRate: 10.0, // 10% commission
      balance: 0.0,
      isActive: true,
    },
    {
      name: "ÿßŸàŸÜÿ± €≤",
      commissionRate: 10.0, // 10% commission
      balance: 0.0,
      isActive: true,
    },
  ];

  const createdCollaborators = await Promise.all(
    salesCollaborators.map((collaborator) =>
      db.salesCollaborator.upsert({
        where: { name: collaborator.name },
        update: collaborator,
        create: collaborator,
      }),
    ),
  );
  console.log(`‚úÖ ${createdCollaborators.length} sales collaborators created.`);

  // 4. Create representatives with exact pricing algorithm implementation
  console.log("üìà Creating representatives with custom pricing algorithm...");
  const representativesSeedData = [
    {
      admin_name: "ŸÜŸÖÿß€åŸÜÿØŸá ŸÜŸÖŸàŸÜŸá ÿ™Ÿáÿ±ÿßŸÜ",
      admin_username: "REP-TEH-01",
      phone_number: "09121112233",
      telegram_id: "123456789",
      basePriceLimitedPerGb: 1500, // Base price for limited plans per GB
      basePriceUnlimitedPerMonth: 50000, // Base price for unlimited plans per month
      salesCollaboratorId: createdCollaborators[0]?.id,
    },
    {
      admin_name: "ŸÜŸÖÿß€åŸÜÿØŸá ŸÜŸÖŸàŸÜŸá ÿßÿµŸÅŸáÿßŸÜ",
      admin_username: "REP-ISF-01",
      phone_number: "ŸÜÿØÿßÿ±ÿØ",
      telegram_id: "987654321",
      basePriceLimitedPerGb: 2000,
      basePriceUnlimitedPerMonth: 60000,
      salesCollaboratorId: createdCollaborators[1]?.id,
    },
    {
      admin_name: "ŸÜŸÖÿß€åŸÜÿØŸá ŸÜŸÖŸàŸÜŸá ÿ¥€åÿ±ÿßÿ≤",
      admin_username: "REP-SHZ-01",
      phone_number: "09133334444",
      telegram_id: "ŸÜÿØÿßÿ±ÿØ",
      basePriceLimitedPerGb: 1800,
      basePriceUnlimitedPerMonth: 55000,
      salesCollaboratorId: createdCollaborators[2]?.id,
    },
  ];

  const sampleRepresentatives: any[] = [];

  for (const repData of representativesSeedData) {
    // --- EXACT PRICING ALGORITHM IMPLEMENTATION ---
    // This implements your core business logic for tier pricing
    const price_tier1 = repData.basePriceLimitedPerGb; // Tier 1-3: Base limited price
    const price_tier2 = repData.basePriceLimitedPerGb;
    const price_tier3 = repData.basePriceLimitedPerGb;
    const price_tier4 = Math.round(repData.basePriceLimitedPerGb * 1.2); // 20% markup
    const price_tier5 = Math.round(repData.basePriceLimitedPerGb * 1.4); // 40% markup
    const price_tier6 = Math.round(repData.basePriceLimitedPerGb * 1.6); // 60% markup
    const price_tier7 = repData.basePriceUnlimitedPerMonth * 1; // Base unlimited
    const price_tier8 = repData.basePriceUnlimitedPerMonth * 2; // 2x unlimited
    const price_tier9 = repData.basePriceUnlimitedPerMonth * 3; // 3x unlimited
    const price_tier10 = repData.basePriceUnlimitedPerMonth * 4; // 4x unlimited
    const price_tier11 = repData.basePriceUnlimitedPerMonth * 5; // 5x unlimited
    const price_tier12 = repData.basePriceUnlimitedPerMonth * 6; // 6x unlimited

    const representative = {
      representativeCode: repData.admin_username,
      persianFullName: repData.admin_name,
      contactInfo: JSON.stringify({
        phone: repData.phone_number === "ŸÜÿØÿßÿ±ÿØ" ? null : repData.phone_number,
        telegramId:
          repData.telegram_id === "ŸÜÿØÿßÿ±ÿØ" ? null : repData.telegram_id,
        address: null,
      }),
      balance: 0.0,
      salesCollaboratorId: repData.salesCollaboratorId || null,
      // Implemented pricing algorithm
      price_tier1,
      price_tier2,
      price_tier3,
      price_tier4,
      price_tier5,
      price_tier6,
      price_tier7,
      price_tier8,
      price_tier9,
      price_tier10,
      price_tier11,
      price_tier12,
    };

    sampleRepresentatives.push(representative);
  }

  const createdRepresentatives = await Promise.all(
    sampleRepresentatives.map((rep) =>
      db.representative.upsert({
        where: { representativeCode: rep.representativeCode },
        update: rep,
        create: rep,
      }),
    ),
  );

  // 5. Create sample invoices using the new pricing algorithm
  console.log("üìÑ Creating sample invoices with tier-based pricing...");
  const sampleInvoices = [
    {
      representativeId: createdRepresentatives[0]!.id,
      invoiceNumber: "INV-000001",
      dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days from now
      status: "PENDING_PAYMENT",
      totalAmount: 163500.0, // Calculated from tier pricing
      paidAmount: 0.0,
      notes: "ÿÆÿØŸÖÿßÿ™ Ÿáÿßÿ≥ÿ™€åŸÜ⁄Ø ŸÖÿ≠ÿØŸàÿØ - ÿ™€åÿ± €±€¥€∞€≥",
      source_data_snapshot: JSON.stringify({
        representativeCode: "REP-TEH-01",
        serviceType: "Limited Hosting",
        tier: 1,
        volume: 100,
      }),
      items: [
        {
          description: "Ÿáÿßÿ≥ÿ™€åŸÜ⁄Ø ŸÖÿ≠ÿØŸàÿØ - ÿ™€åÿ± €± (€±€∞€∞ ⁄Ø€å⁄Øÿßÿ®ÿß€åÿ™)",
          quantity: 100.0, // 100 GB
          unitPrice: 1500, // Tier 1 price from algorithm
          total: 150000, // 100 * 1500
        },
        {
          description: "ŸÖÿßŸÑ€åÿßÿ™ ÿ®ÿ± ÿßÿ±ÿ≤ÿ¥ ÿßŸÅÿ≤ŸàÿØŸá (€π%)",
          quantity: 1.0,
          unitPrice: 13500, // 9% of 150000
          total: 13500,
        },
      ],
    },
    {
      representativeId: createdRepresentatives[1]!.id,
      invoiceNumber: "INV-000002",
      dueDate: new Date(Date.now() + 15 * 24 * 60 * 60 * 1000), // 15 days from now
      status: "DRAFT",
      totalAmount: 130800.0, // Calculated from tier pricing
      paidAmount: 0.0,
      notes: "ÿ≥ÿ±Ÿà€åÿ≥ ŸÜÿßŸÖÿ≠ÿØŸàÿØ ŸÖÿßŸáÿßŸÜŸá - ÿ™€åÿ± €±€¥€∞€≥",
      source_data_snapshot: JSON.stringify({
        representativeCode: "REP-ISF-01",
        serviceType: "Unlimited Monthly",
        tier: 7,
        volume: 2,
      }),
      items: [
        {
          description: "ÿ≥ÿ±Ÿà€åÿ≥ ŸÜÿßŸÖÿ≠ÿØŸàÿØ ŸÖÿßŸáÿßŸÜŸá - ÿ™€åÿ± €∑ (€≤ ŸÖÿßŸá)",
          quantity: 2.0, // 2 months
          unitPrice: 60000, // Tier 7 price from algorithm
          total: 120000, // 2 * 60000
        },
        {
          description: "ŸÖÿßŸÑ€åÿßÿ™ ÿ®ÿ± ÿßÿ±ÿ≤ÿ¥ ÿßŸÅÿ≤ŸàÿØŸá (€π%)",
          quantity: 1.0,
          unitPrice: 10800, // 9% of 120000
          total: 10800,
        },
      ],
    },
    {
      representativeId: createdRepresentatives[2]!.id,
      invoiceNumber: "INV-000003",
      dueDate: new Date(Date.now() + 45 * 24 * 60 * 60 * 1000), // 45 days from now
      status: "PAID",
      totalAmount: 196200.0, // Mixed tier pricing
      paidAmount: 196200.0,
      notes: "ÿ≥ÿ±Ÿà€åÿ≥ ÿ™ÿ±⁄©€åÿ®€å - ÿÆÿ±ÿØÿßÿØ €±€¥€∞€≥",
      source_data_snapshot: JSON.stringify({
        representativeCode: "REP-SHZ-01",
        serviceType: "Mixed Services",
        tiers: [4, 8],
        volumes: [50, 1],
      }),
      items: [
        {
          description: "Ÿáÿßÿ≥ÿ™€åŸÜ⁄Ø ŸÖÿ≠ÿØŸàÿØ - ÿ™€åÿ± €¥ (€µ€∞ ⁄Ø€å⁄Øÿßÿ®ÿß€åÿ™)",
          quantity: 50.0, // 50 GB
          unitPrice: 2160, // Tier 4 price: 1800 * 1.2
          total: 108000, // 50 * 2160
        },
        {
          description: "ÿ≥ÿ±Ÿà€åÿ≥ ŸÜÿßŸÖÿ≠ÿØŸàÿØ - ÿ™€åÿ± €∏ (€± ŸÖÿßŸá)",
          quantity: 1.0, // 1 month
          unitPrice: 110000, // Tier 8 price: 55000 * 2
          total: 110000, // 1 * 110000
        },
        {
          description: "ŸÖÿßŸÑ€åÿßÿ™ ÿ®ÿ± ÿßÿ±ÿ≤ÿ¥ ÿßŸÅÿ≤ŸàÿØŸá (€π%)",
          quantity: 1.0,
          unitPrice: 19620, // 9% of (108000 + 110000)
          total: 19620,
        },
      ],
    },
  ];

  const createdInvoices = await Promise.all(
    sampleInvoices.map(async (invoice) => {
      const { items, ...invoiceData } = invoice;
      return await db.invoice.upsert({
        where: { invoiceNumber: invoice.invoiceNumber },
        update: invoiceData,
        create: {
          ...invoiceData,
          items: {
            create: items,
          },
        },
      });
    }),
  );
  console.log(
    `‚úÖ ${createdInvoices.length} sample invoices created with tier-based pricing.`,
  );

  // 6. Create commission records for invoices with sales collaborators
  console.log("üí∞ Creating commission records...");
  const commissionRecords: any[] = [];
  for (const invoice of createdInvoices) {
    const representative = await db.representative.findUnique({
      where: { id: invoice.representativeId },
      include: { salesCollaborator: true },
    });

    if (representative?.salesCollaborator) {
      const commissionAmount =
        invoice.totalAmount *
        (representative.salesCollaborator.commissionRate / 100);
      const record = await db.commissionRecord.create({
        data: {
          invoiceId: invoice.id,
          salesCollaboratorId: representative.salesCollaborator.id,
          commissionAmount,
          commissionRate: representative.salesCollaborator.commissionRate,
          status: "PENDING",
          notes: `ŸæŸàÿ±ÿ≥ÿßŸÜÿ™ ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿ¥ÿØŸá ÿ®ÿ±ÿß€å ŸÅÿß⁄©ÿ™Ÿàÿ± ${invoice.invoiceNumber} - ŸÜÿ±ÿÆ ${representative.salesCollaborator.commissionRate}%`,
        },
      });
      commissionRecords.push(record);
    }
  }
  console.log(`‚úÖ ${commissionRecords.length} commission records created.`);

  // 7. Create sample CRM interactions
  console.log("üìû Creating sample CRM interactions...");
  const crmInteractions = [
    {
      representativeId: createdRepresentatives[0]!.id,
      interactionType: "CALL",
      subject: "ÿ®ÿ±ÿ±ÿ≥€å ŸÜ€åÿßÿ≤Ÿáÿß€å ÿ¨ÿØ€åÿØ",
      description: "ÿ™ŸÖÿßÿ≥ ÿ®ÿ±ÿß€å ÿ®ÿ±ÿ±ÿ≥€å ŸÜ€åÿßÿ≤Ÿáÿß€å Ÿáÿßÿ≥ÿ™€åŸÜ⁄Ø ÿßÿ∂ÿßŸÅ€å",
      followUpDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
    },
    {
      representativeId: createdRepresentatives[1]!.id,
      interactionType: "TELEGRAM",
      subject: "Ÿæ€å⁄Ø€åÿ±€å Ÿæÿ±ÿØÿßÿÆÿ™",
      description: "Ÿæ€å⁄Ø€åÿ±€å Ÿàÿ∂ÿπ€åÿ™ Ÿæÿ±ÿØÿßÿÆÿ™ ŸÅÿß⁄©ÿ™Ÿàÿ± ŸÇÿ®ŸÑ€å",
      isCompleted: true,
    },
  ];

  await Promise.all(
    crmInteractions.map((interaction) =>
      db.crmInteraction.create({ data: interaction }),
    ),
  );
  console.log(`‚úÖ ${crmInteractions.length} CRM interactions created.`);

  console.log("üéâ Advanced seeding finished successfully.");

  return {
    message:
      "Advanced business logic seeded successfully with exact pricing algorithm",
    collaboratorsCreated: createdCollaborators.length,
    representativesCreated: createdRepresentatives.length,
    invoicesCreated: createdInvoices.length,
    commissionRecordsCreated: commissionRecords.length,
    configsCreated: systemConfigs.length,
    pricingAlgorithm:
      "Implemented with tiers 1-6 for limited plans and tiers 7-12 for unlimited plans",
    businessLogicValidated: true,
  };
}

// Legacy seeding function (kept for backward compatibility)
export async function _seedInitialData() {
  return await _seedAdvancedBusinessLogic();
}

// ===== PHASE 3: ENHANCED API ENDPOINTS FOR ADMIN PANELS =====

// Advanced Dashboard Analytics
export async function getAdvancedDashboardStats() {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const now = new Date();
  const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
  const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
  const last7Days = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);

  const [
    totalRevenue,
    monthlyRevenue,
    overdueAmount,
    activeRepresentatives,
    totalCommissionPayable,
    invoiceStatusBreakdown,
    dailyRevenue,
  ] = await Promise.all([
    // Total revenue (all time)
    db.invoice.aggregate({
      where: { status: "PAID" },
      _sum: { totalAmount: true },
    }),
    // Monthly revenue
    db.invoice.aggregate({
      where: {
        status: "PAID",
        createdAt: { gte: startOfMonth, lte: endOfMonth },
      },
      _sum: { totalAmount: true },
    }),
    // Overdue amount
    db.invoice.aggregate({
      where: {
        status: { in: ["PENDING_PAYMENT", "PARTIALLY_PAID"] },
        dueDate: { lt: now },
      },
      _sum: { totalAmount: true },
    }),
    // Active representatives count
    db.representative.count({ where: { isActive: true } }),
    // Total commission payable
    db.commissionRecord.aggregate({
      where: { status: "PENDING" },
      _sum: { commissionAmount: true },
    }),
    // Invoice status breakdown
    db.invoice.groupBy({
      by: ["status"],
      _count: { status: true },
      _sum: { totalAmount: true },
    }),
    // Daily revenue for last 7 days
    db.invoice.findMany({
      where: {
        status: "PAID",
        createdAt: { gte: last7Days },
      },
      select: {
        totalAmount: true,
        createdAt: true,
      },
    }),
  ]);

  // Process daily revenue data
  const dailyRevenueMap = new Map<string, number>();
  for (let i = 6; i >= 0; i--) {
    const date = new Date(now.getTime() - i * 24 * 60 * 60 * 1000);
    const dateKey =
      date && typeof date.toISOString === "function"
        ? date.toISOString().split("T")[0]
        : "";
    dailyRevenueMap.set(String(dateKey), 0);
  }

  dailyRevenue.forEach((invoice) => {
    const dateKey =
      invoice.createdAt && typeof invoice.createdAt.toISOString === "function"
        ? invoice.createdAt.toISOString().split("T")[0]
        : "";
    if (dateKey && dailyRevenueMap.has(dateKey)) {
      dailyRevenueMap.set(
        dateKey,
        (dailyRevenueMap.get(dateKey) ?? 0) + invoice.totalAmount,
      );
    }
  });

  const dailyRevenueChart = Array.from(dailyRevenueMap.entries()).map(
    ([date, amount]) => ({
      date,
      revenue: Math.round(amount),
    }),
  );

  return {
    totalRevenue: totalRevenue._sum.totalAmount || 0,
    monthlyRevenue: monthlyRevenue._sum.totalAmount || 0,
    overdueAmount: overdueAmount._sum.totalAmount || 0,
    activeRepresentatives,
    totalCommissionPayable: totalCommissionPayable._sum.commissionAmount || 0,
    invoiceStatusBreakdown: invoiceStatusBreakdown.map((item) => ({
      status: item.status,
      count: item._count.status,
      amount: item._sum.totalAmount || 0,
    })),
    dailyRevenueChart,
  };
}

// Enhanced Representative Management
export async function getRepresentativeProfile({ id }: { id: string }) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const representative = await db.representative.findUnique({
    where: { id },
    include: {
      salesCollaborator: true,
      invoices: {
        orderBy: { createdAt: "desc" },
        include: {
          items: true,
        },
      },
      payments: {
        orderBy: { paymentDate: "desc" },
        include: {
          allocations: {
            include: {
              invoice: true,
            },
          },
        },
      },
    },
  });

  if (!representative) {
    throw new Error("Representative not found");
  }

  // Calculate additional statistics
  const totalDebt = representative.invoices
    .filter((inv) => inv.status !== "PAID")
    .reduce((sum, inv) => sum + (inv.totalAmount - inv.paidAmount), 0);

  const totalSales = representative.invoices.reduce(
    (sum, inv) => sum + inv.totalAmount,
    0,
  );

  const paidInvoices = representative.invoices.filter(
    (inv) => inv.status === "PAID",
  ).length;

  return {
    ...representative,
    statistics: {
      totalDebt: Math.round(totalDebt),
      totalSales: Math.round(totalSales),
      paidInvoices,
      totalInvoices: representative.invoices.length,
      paymentReliability:
        representative.invoices.length > 0
          ? Math.round((paidInvoices / representative.invoices.length) * 100)
          : 0,
    },
  };
}

export async function updateRepresentativeProfile(input: {
  id: string;
  persianFullName?: string;
  contactInfo?: string;
  salesCollaboratorId?: string | null;
  isActive?: boolean;
  price_tier1?: number;
  price_tier2?: number;
  price_tier3?: number;
  price_tier4?: number;
  price_tier5?: number;
  price_tier6?: number;
  price_tier7?: number;
  price_tier8?: number;
  price_tier9?: number;
  price_tier10?: number;
  price_tier11?: number;
  price_tier12?: number;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const { id, ...updateData } = input;

  return await db.representative.update({
    where: { id },
    data: updateData,
    include: {
      salesCollaborator: true,
    },
  });
}

export async function deleteRepresentative(input: { id: string }) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.representative.delete({ where: { id: input.id } });
}

// Sales Collaborator Management
// ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å ÿß€åÿ¨ÿßÿØ Ÿà Ÿà€åÿ±ÿß€åÿ¥ ŸáŸÖ⁄©ÿßÿ±
const collaboratorSchema = z.object({
  name: z.string().min(3, "ŸÜÿßŸÖ ÿ®ÿß€åÿØ ÿ≠ÿØÿßŸÇŸÑ €≥ ⁄©ÿßÿ±ÿß⁄©ÿ™ÿ± ÿ®ÿßÿ¥ÿØ"),
  city: z.string().optional(),
  phone: z.string().optional(),
  telegramId: z.string().optional(),
  commissionRate: z.number().min(0).max(100),
});

export async function listCollaborators() {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.salesCollaborator.findMany({
    include: { _count: { select: { representatives: true } } },
    orderBy: { createdAt: "desc" },
  });
}

export async function createCollaborator(input: {
  name: string;
  city?: string;
  phone?: string;
  telegramId?: string;
  commissionRate: number;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const safeInput = collaboratorSchema.parse(input);
  return await db.salesCollaborator.create({ data: safeInput });
}

export async function updateCollaborator(input: {
  id: string;
  name?: string;
  city?: string;
  phone?: string;
  telegramId?: string;
  commissionRate?: number;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");
  const { id, ...updateData } = input;
  // ÿßÿπÿ™ÿ®ÿßÿ±ÿ≥ŸÜÿ¨€å ŸÖŸÇÿßÿØ€åÿ± ÿ¨ÿØ€åÿØ (ÿØÿ± ÿµŸàÿ±ÿ™ Ÿàÿ¨ŸàÿØ)
  collaboratorSchema.partial().parse(updateData);
  return await db.salesCollaborator.update({ where: { id }, data: updateData });
}

export async function deleteCollaborator(input: { id: string }) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");
  return await db.salesCollaborator.delete({ where: { id: input.id } });
}

export async function listSalesCollaborators() {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.salesCollaborator.findMany({
    orderBy: { name: "asc" },
    include: {
      _count: {
        select: { representatives: true },
      },
    },
  });
}

// Payment Management
export async function getRepresentativePayments({
  representativeId,
}: {
  representativeId: string;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.payment.findMany({
    where: { representativeId },
    orderBy: { paymentDate: "desc" },
    include: {
      allocations: {
        include: {
          invoice: {
            select: {
              invoiceNumber: true,
              totalAmount: true,
            },
          },
        },
      },
    },
  });
}

export async function createPayment(input: {
  representativeId: string;
  amount: number;
  paymentMethod: string;
  referenceNumber?: string;
  description?: string;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.$transaction(async (tx) => {
    // Create the payment record
    const payment = await tx.payment.create({
      data: {
        ...input,
        isConfirmed: true,
      },
      include: {
        representative: true,
      },
    });

    // Update representative balance
    await tx.representative.update({
      where: { id: input.representativeId },
      data: {
        balance: {
          increment: input.amount,
        },
      },
    });

    // Auto-allocate payment to unpaid invoices
    const unpaidInvoices = await tx.invoice.findMany({
      where: {
        representativeId: input.representativeId,
        status: { in: ["PENDING_PAYMENT", "PARTIALLY_PAID"] },
      },
      orderBy: { dueDate: "asc" },
    });

    let remainingAmount = input.amount;
    for (const invoice of unpaidInvoices) {
      if (remainingAmount <= 0) break;

      const unpaidAmount = invoice.totalAmount - invoice.paidAmount;
      const allocationAmount = Math.min(remainingAmount, unpaidAmount);

      if (allocationAmount > 0) {
        // Create payment allocation
        await tx.paymentAllocation.create({
          data: {
            paymentId: payment.id,
            invoiceId: invoice.id,
            amount: allocationAmount,
          },
        });

        // Update invoice paid amount and status
        const newPaidAmount = invoice.paidAmount + allocationAmount;
        const newStatus =
          newPaidAmount >= invoice.totalAmount
            ? "PAID"
            : newPaidAmount > 0
              ? "PARTIALLY_PAID"
              : "PENDING_PAYMENT";

        await tx.invoice.update({
          where: { id: invoice.id },
          data: {
            paidAmount: newPaidAmount,
            status: newStatus,
          },
        });

        remainingAmount -= allocationAmount;
      }
    }

    return payment;
  });
}

export async function updatePayment(input: {
  id: string;
  paymentMethod?: string;
  referenceNumber?: string;
  description?: string;
  isConfirmed?: boolean;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const { id, ...data } = input;

  return await db.payment.update({
    where: { id },
    data,
  });
}

export async function deletePayment(input: { id: string }) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");
  return await db.payment.delete({ where: { id: input.id } });
}

// ===== ÿ®ÿÆÿ¥ €≤: €å⁄©Ÿæÿßÿ±⁄ÜŸá‚Äåÿ≥ÿßÿ≤€å ÿ®ÿß ÿ™ŸÑ⁄Øÿ±ÿßŸÖ (Telegram Integration) =====

/**
 * ÿ≥ÿ±Ÿà€åÿ≥ ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ÿ®ÿ±ÿß€å ÿßÿ±ÿ≥ÿßŸÑ Ÿæ€åÿßŸÖ Ÿà ÿ™ÿµÿßŸà€åÿ± ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ node-telegram-bot-api
 */
export class TelegramService {
  private static readonly BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
  private static bot: TelegramBot | null = null;

  private static getBotInstance(): TelegramBot {
    if (!this.BOT_TOKEN) {
      throw new Error("TELEGRAM_BOT_TOKEN environment variable is not set");
    }
    if (!this.bot) {
      this.bot = new TelegramBot(this.BOT_TOKEN);
    }
    return this.bot;
  }

  /**
   * ÿßÿ±ÿ≥ÿßŸÑ ÿ™ÿµŸà€åÿ± ÿ®ÿß ⁄©Ÿæÿ¥ŸÜ ÿ®Ÿá ÿ™ŸÑ⁄Øÿ±ÿßŸÖ
   */
  private static async sendPhoto(
    chatId: string,
    photoBuffer: Buffer,
    caption?: string,
  ): Promise<{ success: boolean; messageId?: number; error?: string }> {
    try {
      const bot = this.getBotInstance();
      const message = await bot.sendPhoto(chatId, photoBuffer, {
        caption,
        parse_mode: "HTML",
      });
      return { success: true, messageId: message.message_id };
    } catch (error: any) {
      console.error("Telegram sendPhoto error:", error);
      return {
        success: false,
        error:
          error.response?.body?.description ||
          error.message ||
          "Unknown Telegram API error",
      };
    }
  }

  /**
   * ÿ™ŸàŸÑ€åÿØ ÿ™ÿµŸà€åÿ± ŸÅÿß⁄©ÿ™Ÿàÿ± (Placeholder)
   */
  private static async generateInvoiceImage(invoice: any): Promise<Buffer> {
    const text = `
      Invoice: ${invoice.invoiceNumber}
      Rep: ${invoice.representative.persianFullName}
      Amount: ${invoice.totalAmount.toLocaleString()} Toman
      Date: ${new Date(invoice.issueDate).toLocaleDateString("fa-IR")}
    `;
    const { createCanvas } = require("canvas");
    const canvas = createCanvas(400, 200);
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, 400, 200);
    ctx.fillStyle = "black";
    ctx.font = "16px Vazirmatn";
    const lines = text.trim().split("\n");
    let y = 30;
    for (const line of lines) {
      ctx.fillText(line.trim(), 20, y);
      y += 25;
    }
    return canvas.toBuffer("image/png");
  }

  /**
   * ŸÖŸÜÿ∑ŸÇ ÿßÿµŸÑ€å ÿßÿ±ÿ≥ÿßŸÑ €å⁄© ŸÅÿß⁄©ÿ™Ÿàÿ± ÿ®Ÿá ÿßÿØŸÖ€åŸÜ
   */
  public static async sendInvoiceToAdmin(input: {
    invoice: any; // Ideally a strongly-typed invoice object
    adminChatId: string;
    storeName: string;
  }) {
    const { invoice, adminChatId, storeName } = input;

    let contactInfo: { telegramId?: string } = {};
    try {
      if (invoice.representative.contactInfo) {
        contactInfo = JSON.parse(invoice.representative.contactInfo) as {
          telegramId?: string;
        };
      }
    } catch (e) {
      console.error("Failed to parse representative contact info", e);
    }
    const repTelegramId = contactInfo.telegramId || "N/A";

    const imageBuffer = await this.generateInvoiceImage(invoice);

    const caption = `
üßæ <b>ÿßÿ±ÿ≥ÿßŸÑ ŸÅÿß⁄©ÿ™Ÿàÿ± ÿ®ÿ±ÿß€å ÿßÿØŸÖ€åŸÜ</b>

üè¢ <b>ŸÅÿ±Ÿàÿ¥⁄ØÿßŸá:</b> ${storeName}
üë®‚Äçüíº <b>ŸÜŸÖÿß€åŸÜÿØŸá:</b> ${invoice.representative.persianFullName}
üìû <b>ÿ¢€å‚ÄåÿØ€å ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ŸÜŸÖÿß€åŸÜÿØŸá:</b> <code>${repTelegramId}</code>
üî¢ <b>⁄©ÿØ ŸÜŸÖÿß€åŸÜÿØŸá:</b> ${invoice.representative.representativeCode}
---
üìã <b>ÿ¥ŸÖÿßÿ±Ÿá ŸÅÿß⁄©ÿ™Ÿàÿ±:</b> ${invoice.invoiceNumber}
üí∞ <b>ŸÖÿ®ŸÑÿ∫:</b> ${invoice.totalAmount.toLocaleString()} ÿ™ŸàŸÖÿßŸÜ
üìÖ <b>ÿ≥ÿ±ÿ±ÿ≥€åÿØ:</b> ${invoice.dueDate ? new Date(invoice.dueDate).toLocaleDateString("fa-IR") : "N/A"}
---
ÿß€åŸÜ Ÿæ€åÿßŸÖ ÿ¨Ÿáÿ™ ÿßÿ∑ŸÑÿßÿπ ÿßÿØŸÖ€åŸÜ ÿßÿ±ÿ≥ÿßŸÑ ÿ¥ÿØŸá ÿßÿ≥ÿ™.
    `
      .trim()
      .replace(/  +/g, "");

    return await this.sendPhoto(adminChatId, imageBuffer, caption);
  }
}

/**
 * PRIVATE HELPER: Sends a single invoice and updates DB. Not an RPC endpoint.
 */
async function _sendSingleInvoiceToTelegram(invoiceId: string) {
  const ADMIN_CHAT_ID = process.env.TELEGRAM_ADMIN_CHAT_ID;
  if (!ADMIN_CHAT_ID) {
    throw new Error("TELEGRAM_ADMIN_CHAT_ID environment variable is not set");
  }

  const invoice = await db.invoice.findUnique({
    where: { id: invoiceId },
    include: { representative: true, items: true },
  });

  if (!invoice) throw new Error(`Invoice with ID ${invoiceId} not found`);

  const configs = await db.systemConfig.findMany();
  const configMap = configs.reduce(
    (acc, config) => {
      acc[config.key] = config.value;
      return acc;
    },
    {} as Record<string, string>,
  );
  const storeName = configMap.company_name || "Phoenix Invoice";

  const result = await TelegramService.sendInvoiceToAdmin({
    invoice,
    adminChatId: ADMIN_CHAT_ID,
    storeName,
  });

  const dispatchStatus = {
    status: result.success ? "sent" : "failed",
    sentAt: new Date().toISOString(),
    messageId: result.messageId?.toString() || null,
    errorMessage: result.error || null,
  };

  await db.invoice.update({
    where: { id: invoiceId },
    data: { telegram_dispatch_status: JSON.stringify(dispatchStatus) },
  });

  if (!result.success) {
    throw new Error(result.error || "Failed to send invoice to Telegram");
  }

  return { success: true, dispatchStatus };
}

/**
 * ÿßÿ±ÿ≥ÿßŸÑ ÿ™⁄©€å ŸÅÿß⁄©ÿ™Ÿàÿ± ÿ®Ÿá ÿßÿØŸÖ€åŸÜ ÿØÿ± ÿ™ŸÑ⁄Øÿ±ÿßŸÖ
 */
export async function dispatchInvoiceToTelegram(input: { invoiceId: string }) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await _sendSingleInvoiceToTelegram(input.invoiceId);
}

/**
 * ÿßÿ±ÿ≥ÿßŸÑ ÿØÿ≥ÿ™Ÿá‚Äåÿ¨ŸÖÿπ€å ŸÅÿß⁄©ÿ™Ÿàÿ±Ÿáÿß ÿ®Ÿá ÿ™ŸÑ⁄Øÿ±ÿßŸÖ ÿ®ÿß ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿßÿ≤ ÿ≥€åÿ≥ÿ™ŸÖ ÿ™ÿ≥⁄© Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá
 */
export async function bulkDispatchInvoicesToTelegram() {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const task = await queueTask(async () => {
    console.log(`üöÄ Starting bulk dispatch job...`);

    const pendingInvoices = await db.invoice.findMany({
      where: {
        OR: [
          { telegram_dispatch_status: null },
          { telegram_dispatch_status: { contains: '"status":"pending"' } },
          { telegram_dispatch_status: { contains: '"status":"failed"' } },
        ],
      },
      select: { id: true, invoiceNumber: true },
      take: 50, // ŸÖÿ≠ÿØŸàÿØ€åÿ™ ÿ®ÿ±ÿß€å Ÿáÿ± ÿ®ÿßÿ± ÿßÿ¨ÿ±ÿß
    });

    console.log(`üìä Found ${pendingInvoices.length} invoices to dispatch`);

    let successCount = 0;
    let failureCount = 0;

    for (const invoice of pendingInvoices) {
      try {
        // ŸÅÿßÿµŸÑŸá ÿ≤ŸÖÿßŸÜ€å ÿ®ÿ±ÿß€å ÿ¨ŸÑŸà⁄Ø€åÿ±€å ÿßÿ≤ rate limiting ÿ™ŸÑ⁄Øÿ±ÿßŸÖ
        await new Promise((resolve) => setTimeout(resolve, 2000));
        await _sendSingleInvoiceToTelegram(invoice.id);
        successCount++;
        console.log(`‚úÖ Invoice ${invoice.invoiceNumber} sent successfully`);
      } catch (error) {
        failureCount++;
        console.error(
          `‚ùå Failed to send invoice ${invoice.invoiceNumber}:`,
          error,
        );
      }
    }
    console.log(
      `üéâ Bulk dispatch completed: ${successCount} success, ${failureCount} failed`,
    );
  });

  return task;
}

/**
 * ÿØÿ±€åÿßŸÅÿ™ Ÿàÿ∂ÿπ€åÿ™ ÿ™ÿ≥⁄© ÿßÿ±ÿ≥ÿßŸÑ ÿØÿ≥ÿ™Ÿá‚Äåÿ¨ŸÖÿπ€å
 */
export async function getBulkDispatchStatus(input: { taskId: string }) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await getTaskStatus(input.taskId);
}

/**
 * ÿØÿ±€åÿßŸÅÿ™ ÿ¢ŸÖÿßÿ± ÿßÿ±ÿ≥ÿßŸÑ ÿ™ŸÑ⁄Øÿ±ÿßŸÖ
 */
export async function getTelegramDispatchStats() {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const [totalInvoices, sentInvoices, failedInvoices, pendingInvoices] =
    await Promise.all([
      db.invoice.count(),
      db.invoice.count({
        where: {
          telegram_dispatch_status: { contains: '"status":"sent"' },
        },
      }),
      db.invoice.count({
        where: {
          telegram_dispatch_status: { contains: '"status":"failed"' },
        },
      }),
      db.invoice.count({
        where: {
          OR: [
            { telegram_dispatch_status: null },
            { telegram_dispatch_status: { contains: '"status":"pending"' } },
          ],
        },
      }),
    ]);

  return {
    totalInvoices,
    sentInvoices,
    failedInvoices,
    pendingInvoices,
    successRate:
      totalInvoices > 0 ? Math.round((sentInvoices / totalInvoices) * 100) : 0,
  };
}

// Commission Payout Management
export async function _bulkImportRepresentatives(input: {
  records: any[];
}): Promise<{
  createdCount: number;
  updatedCount: number;
  errors: { representativeCode: string; reason: string }[];
}> {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const { records } = input;
  if (!Array.isArray(records)) {
    throw new Error("Input must be an array of representative records.");
  }

  let createdCount = 0;
  let updatedCount = 0;
  const errors: { representativeCode: string; reason: string }[] = [];

  for (const record of records) {
    const representativeCode = record.representativeCode;
    if (!representativeCode) {
      errors.push({
        representativeCode: "N/A",
        reason: "Missing representativeCode in record.",
      });
      continue;
    }

    try {
      // Step 1: Find Collaborator ID
      let collaboratorId: string | null = null;
      if (record.collaboratorName) {
        const collaborator = await db.salesCollaborator.findUnique({
          where: { name: record.collaboratorName },
        });
        if (collaborator) {
          collaboratorId = collaborator.id;
        }
      }

      // Check if representative exists to correctly count create vs update
      const existingRep = await db.representative.findUnique({
        where: { representativeCode },
      });

      // Prepare data for upsert
      const representativeData = {
        representativeCode,
        persianFullName: record.persianFullName,
        contactInfo: JSON.stringify(record.contactInfo || {}),
        salesCollaboratorId: collaboratorId,
        ...record.pricingTiers,
      };

      // Step 2: Upsert Representative
      await db.representative.upsert({
        where: { representativeCode },
        create: representativeData,
        update: representativeData,
      });

      if (existingRep) {
        updatedCount++;
      } else {
        createdCount++;
      }
    } catch (error: any) {
      errors.push({
        representativeCode,
        reason: error.message || "An unknown error occurred.",
      });
    }
  }

  return { createdCount, updatedCount, errors };
}

export async function listCommissionRecords() {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.commissionRecord.findMany({
    orderBy: { calculatedAt: "desc" },
    include: {
      invoice: {
        include: {
          representative: true,
        },
      },
      salesCollaborator: true,
    },
  });
}

export async function createCommissionPayout(input: {
  salesCollaboratorId: string;
  amount: number;
  description?: string;
  referenceNumber?: string;
}) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  return await db.$transaction(async (tx) => {
    // Verify collaborator has enough balance
    const collaborator = await tx.salesCollaborator.findUnique({
      where: { id: input.salesCollaboratorId },
    });

    if (!collaborator) {
      throw new Error("Sales collaborator not found");
    }

    if (collaborator.balance < input.amount) {
      throw new Error(
        `Insufficient balance. Available: ${collaborator.balance.toLocaleString()} Toman, Requested: ${input.amount.toLocaleString()} Toman`,
      );
    }

    // Create payout record
    const payout = await tx.commissionPayout.create({
      data: {
        salesCollaboratorId: input.salesCollaboratorId,
        amount: input.amount,
        description: input.description || "Commission payout",
        referenceNumber: input.referenceNumber,
      },
      include: {
        salesCollaborator: true,
      },
    });

    // Update collaborator balance
    await tx.salesCollaborator.update({
      where: { id: input.salesCollaboratorId },
      data: {
        balance: {
          decrement: input.amount,
        },
      },
    });

    // Mark related commission records as paid
    const pendingCommissions = await tx.commissionRecord.findMany({
      where: {
        salesCollaboratorId: input.salesCollaboratorId,
        status: "PENDING",
      },
      orderBy: { calculatedAt: "asc" },
    });

    let remainingAmount = input.amount;
    for (const commission of pendingCommissions) {
      if (remainingAmount <= 0) break;

      if (commission.commissionAmount <= remainingAmount) {
        await tx.commissionRecord.update({
          where: { id: commission.id },
          data: {
            status: "PAID",
            paidAt: new Date(),
            notes:
              `${commission.notes || ""} - Paid via payout ${payout.id}`.trim(),
          },
        });
        remainingAmount -= commission.commissionAmount;
      }
    }

    return payout;
  });
}

export async function getSalesCollaboratorProfile({ id }: { id: string }) {
  const { userId } = await getAuth({ required: true });
  const user = await db.user.findUnique({ where: { id: userId } });
  if (!user?.isAdmin) throw new Error("Unauthorized");

  const collaborator = await db.salesCollaborator.findUnique({
    where: { id },
    include: {
      representatives: {
        include: {
          _count: {
            select: { invoices: true },
          },
        },
      },
      commissionRecords: {
        orderBy: { calculatedAt: "desc" },
        include: {
          invoice: {
            include: {
              representative: true,
            },
          },
        },
      },
      commissionPayouts: {
        orderBy: { payoutDate: "desc" },
      },
    },
  });

  if (!collaborator) {
    throw new Error("Sales collaborator not found");
  }

  // Calculate statistics
  const totalCommissionEarned = collaborator.commissionRecords.reduce(
    (sum, record) => sum + record.commissionAmount,
    0,
  );

  const totalCommissionPaid = collaborator.commissionPayouts.reduce(
    (sum, payout) => sum + payout.amount,
    0,
  );

  const pendingCommissions = collaborator.commissionRecords
    .filter((record) => record.status === "PENDING")
    .reduce((sum, record) => sum + record.commissionAmount, 0);

  return {
    ...collaborator,
    statistics: {
      totalCommissionEarned: Math.round(totalCommissionEarned),
      totalCommissionPaid: Math.round(totalCommissionPaid),
      pendingCommissions: Math.round(pendingCommissions),
      totalRepresentatives: collaborator.representatives.length,
      activeRepresentatives: collaborator.representatives.filter(
        (rep) => rep.isActive,
      ).length,
    },
  };
}
